> All Kotlin programs need to have a main() function

fun main(var_name : data_type,var_name : data_type ) {
    var age = 18
    println("Happy Birthday Shubhi")
    println("You are already ${age}!")
}

> fun stands for function. 
> main is the name of this function.
> comment //
> constants : 
    val age = "5"

> variable : 
    var roll = "6"
    var rolledValue: Int = 4

> loop :
    repeat(number)

> print 
    println \n = one full blank line
    print \n = next line

> condition statement
    if 
    else if
    else

Earlier, you learned that every Kotlin program must have a main() function. 
Android apps operate differently. 
Instead of calling a main() function, the Android system calls the onCreate() 
method of your MainActivity when your app is opened for the first time.

Android provides a framework of numerous classes to make writing Android apps easier,
but it needs to know exactly which class you mean. You can specify which class in the 
framework to use in your code by using an import statement. 
For example, the Button class is defined in android.widget.Button.

There are many assertions in the JUnit library. Some common assertions you might encounter are:

    assertEquals()
    assertNotEquals()
    assertThat()
    assertTrue()
    assertFalse()
    assertNull()
    assertNotNull()

An app can technically run more than one Kotlin function at once.
This is possible because of something called threads.

android 
{
    BuildFeatures
    {
        viewBinding = true
    }
}
val intent = Intent(this,SomeActivity::class.java)
startActivity(intent)

Use the super keyword to call the function that is defined in the parent.

XML stands for eXtensible Markup Language, which is a way of describing data using a text-based document.
Android Jetpack

ConstraintLayout is part of Android Jetpack, which contains libraries of code which offers additional functionality on top of the core Android platform. Jetpack has useful functionality you can take advantage of to make building apps easier. You'll recognize this UI component is part of Jetpack because it starts with "androidx".

strings.xml (app > res > values > strings.xml).
themes.xml (app > res > values > themes > themes.xml).
https://material.io/resources/color/#!/?view.left=0&view.right=0

#theme of app

add color in string
add string in theme


#app logo

Resource Manager >  Image Asset 

Project window, switch to the Project view.
(app > src > main > res )

A bitmap image doesn't understand much about the image that it holds, except for the color information at each pixel. On the other hand, a vector graphic knows how to draw the shapes that define an image.  icons can be ideal as vector drawables because they are made up of simple shapes, while a photograph would be harder to describe as a series of shapes. It would be more efficient to use a bitmap asset in that case.

there are certain requirements on these foreground and background layer assets, such as both must be 108dp x 108dp in size. The inner 72 x 72 dp of the icon appears within the masked viewport. The outer 18 dp on each of the 4 sides of the layers is reserved for use by the system UI surfaces to create interesting visual effects, such as parallax or pulsing.